- [UML 建模过程](#modelingProcess)
- [UML 核心元素](#coreElements)
    - [参与者](#paticipant)
    - [用例](#useCase)
    - [边界](#boundary)
- 
<h1 id = "modelingProcess">建模过程</h1>
现实世界 --> 业务模型 --> 概念模型 --> 设计模型

<br>

----------------------------------------------

<h1 id = "coreElements">UML 核心元素</h1>

<h2 id = "paticipant"> 参与者 </h2>
确定参与者，明确系统边界，参与者位于边界之外。<br><br>

如何确定参与者：
1. 谁对系统有着明确的目标和要求并且主动发出动作?
2. 系统是为谁服务的?

**业务主角**：参与者，与业务系统有着交互的人和事务，没有计算机系统这些业务人员也客观存在；在初始需求阶段，使用业务主角。业务主角是客户实际业务里的参与者，没有计算机系统，也没有抽象的计算机角色。<br>

**业务工人**：非参与者，被动参与业务的，而且处于系统边界内。<br>

**涉众**：也称干系人，与系统有利益关系的都是这个项目的涉众。参与者是涉众的代表。<br>

**用户**：系统的使用者，用户是参与者的代表，并非所有参与者都是用户，但是一个用户可以代理多个参与者。

**角色**：角色是参与者的职责。从众多参与者的职责中抽象出相同的一部分，将其命名为一个角色。一个用户可以代理多个参与者，因此一个用户可以拥有多个职责，也就是可以被指定多个角色。

<br>
<br>

<h2 id = "useCase">用例</h2>

**用例**是一种把现实世界的需求捕获下来的方法。一个完整的用例由参与者、前置条件、场景、后置条件构成。<br><br>

<h3>用例的作用</h3>
捕捉功能性需求，这就是用例的作用。
<br>

<h3>用例的特征</h3>

1. **用例是相对独立的。** 即不需要与其他用例交互，可以独自完成参与者的目的，功能是完备的。<br>

2. **用例的执行结果对参与者来说是可观测的和有意义的。** 比如说我网购，东西怎么运输过来的是没有意义的；或者我淘宝买东西，淘宝的后台系统操作对我来说也是没有意义的。<br>

3. **用例由一个参与者发起，不存在没有参与者的用例，用例不应该自启动。**<br>

4. 用例必须有一个动作和一个动作的受体。<br>

5. 一个用例就是一个需求单元、分析单元、设计单元、开发单元、测试单元，甚至部署单元。一旦确定用例，软件开发工作的其他活动都以这个用例为基础，围绕着它进行。**用例驱动** 软件开发活动。<br>

<br>
<br>

<h3>用例的粒度</h3>

**业务建模阶段**：一个用例可以描述一项完整的业务流程 <br>
**概念建模阶段**：一个用例描述一项完整业务中的一个步骤 <br>
**系统建模阶段**：针对计算机，以一个用例能够描述操作者与计算机的一次完整交互为宜 <br>

<br>

总体原则是在同一个需求阶段，所有用例的粒度应该是同一个量级的，粒度选择的问题本质上还是因为边界认定不同而产生的。如果出现了同一个阶段粒度大小不一的情况，应该首先确认是否选择了正确的边界并检查自己是否越过了这个边界。
<br>
<br>

<h3>用例的获得</h3>

用例的来源就是参与者对系统的期望。所以发现用例的前提条件就是发现参与者，确定参与者的同时就确定了系统的边界。
<br>

**三问：**
- 参与者位于系统边界外
- 参与者对系统有明确的期望和明确的回报要求
- 主角的期望和回报要求在系统边界之内

<br>

**举例：**
银行中，取钱、存钱是用例，插入卡片、输入密码则只是一个步骤，挂失银行卡也是用例，支持跨行业务则是一个业务规则。

<br>
<br>

<h3>用例和功能的误区</h3>

功能是结果，而用例是要包含参与者使用过程的 <br>

**举例：**
电视从功能出发，能开关，能显示，换频道，调声音。上面四个功能是独立的；从用例出发则是，一个人要观看电视的用例，第一步要打开开关，调到自己喜欢的频道，还可以调到合适的音量大小，以上三者是因人的需求而相关起来的。

<br>
<br>

<h2 id = "boundary">边界</h2>

边界在UML图符中就是一个简单的矩形框，在收集需求的过程中，先要假设一个范围边界，在这个边界中寻找需求，找的需求集合又决定了最终边界的大小。边界决定抽象层次。需要灵活使用边界。

<br>
<br>


